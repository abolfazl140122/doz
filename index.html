<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>پروژه غول صوتی - چت صوتی یکپارچه</title>
    
    <!-- CSS داخلی -->
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
            direction: rtl; /* برای فارسی */
            text-align: right;
            line-height: 1.6;
        }

        h1, h2, h3 {
            color: #0056b3;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 15px;
        }

        div.section {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px; /* برای فاصله بین دکمه‌ها */
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

        input[type="text"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: calc(100% - 150px); /* عرض مناسب */
            max-width: 300px;
            box-sizing: border-box; /* برای محاسبه درست padding و border */
            margin-left: 10px;
        }
        
        #username-input {
            width: 200px;
        }

        #login-anon-btn {
            background-color: #6c757d;
        }
        #login-anon-btn:hover {
            background-color: #5a6268;
        }

        #logout-btn {
            background-color: #dc3545;
        }
        #logout-btn:hover {
            background-color: #c82333;
        }
        
        #toggle-mic-btn {
            background-color: #28a745; /* Green for mic on */
            margin-left: 0;
            margin-right: 10px;
        }

        #room-list, #room-members, #chat-messages {
            border: 1px solid #ddd;
            padding: 10px;
            max-height: 250px;
            overflow-y: auto;
            background-color: #f9f9f9;
            border-radius: 5px;
            margin-bottom: 15px;
            list-style: none; /* برای ul */
            padding-right: 10px; /* برای ul */
        }

        #room-list div {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #eee;
        }
        #room-list div:last-child {
            border-bottom: none;
        }

        .chat-message {
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .chat-message strong {
            color: #007bff;
            margin-left: 5px;
        }
        .chat-message span.timestamp {
            font-size: 0.8em;
            color: #888;
            margin-right: 10px;
        }

        audio {
            display: none; /* پنهان کردن تگ صوتی، چون فقط برای پخش استفاده می‌شود */
        }

        #remote-audios {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            input[type="text"] {
                width: calc(100% - 20px);
                max-width: none;
                margin-left: 0;
            }
            button {
                width: 100%;
                margin-left: 0;
                margin-top: 10px;
            }
            #room-list div {
                flex-direction: column;
                align-items: flex-end;
            }
            #room-list div button {
                width: auto;
                margin-top: 5px;
            }
        }
    </style>
    
    <!-- SDK های Firebase -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.19.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.19.1/firebase-analytics.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.19.1/firebase-auth.js";
        import { getDatabase, ref, push, set, onValue, remove, update } from "https://www.gstatic.com/firebasejs/9.19.1/firebase-database.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyAk3aehEN_aCT0VHE29sSI72Htpb7vbAk", // Replace with your actual apiKey
          authDomain: "voic-acfa3.firebaseapp.com",
          projectId: "voic-acfa3",
          storageBucket: "voic-acfa3.firebasestorage.app",
          messagingSenderId: "7797643208",
          appId: "1:7797643208:web:ca69e49eb448a96cf8d2fd",
          measurementId: "G-1VQXZKZ6T9"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app); 

        // Export Firebase services (accessible only within this module script)
        const auth = getAuth(app);
        const db = getDatabase(app);

        // UI Elements
        const authSection = document.getElementById('auth-section');
        const usernameInput = document.getElementById('username-input');
        const loginAnonBtn = document.getElementById('login-anon-btn');
        const userInfo = document.getElementById('user-info');
        const currentUsernameSpan = document.getElementById('current-username');
        const logoutBtn = document.getElementById('logout-btn');

        const roomListSection = document.getElementById('room-list-section');
        const roomListDiv = document.getElementById('room-list');
        const newRoomNameInput = document.getElementById('new-room-name');
        const createRoomBtn = document.getElementById('create-room-btn');

        const roomSection = document.getElementById('room-section');
        const roomTitle = document.getElementById('room-title');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const toggleMicBtn = document.getElementById('toggle-mic-btn');
        const roomMembersList = document.getElementById('room-members');
        const chatMessagesDiv = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        const remoteAudiosDiv = document.getElementById('remote-audios');

        // Global state
        let currentUser = null;
        let currentRoomId = null;
        let localStream = null;
        let peerConnections = {}; // {userId: RTCPeerConnection}
        let userDisplayName = "کاربر ناشناس";
        let micEnabled = false;

        // --- Firebase Authentication ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                // Load or set username
                const userRef = ref(db, `users/${user.uid}`);
                const snapshot = await get(userRef); // Use get() for single read
                if (snapshot.exists()) {
                    userDisplayName = snapshot.val().username || `کاربر #${user.uid.substring(0, 5)}`;
                } else {
                    userDisplayName = usernameInput.value.trim() || `کاربر #${user.uid.substring(0, 5)}`;
                    await set(userRef, {
                        username: userDisplayName,
                        email: user.email || null, // For anonymous, email is null
                        lastOnline: Date.now()
                    });
                }
                currentUsernameSpan.textContent = userDisplayName;
                authSection.style.display = 'none';
                roomListSection.style.display = 'block';
                userInfo.style.display = 'flex'; // Use flex for alignment
                listenToRooms(); // Start listening for rooms
            } else {
                currentUser = null;
                userDisplayName = "کاربر ناشناس";
                authSection.style.display = 'block';
                roomListSection.style.display = 'none';
                roomSection.style.display = 'none';
                userInfo.style.display = 'none';
                usernameInput.value = ''; // Clear username input on logout
            }
        });

        loginAnonBtn.addEventListener('click', () => {
            signInAnonymously(auth).catch(error => {
                console.error("خطا در ورود ناشناس:", error);
                alert("خطا در ورود: " + error.message);
            });
        });

        logoutBtn.addEventListener('click', async () => {
            if (currentRoomId) {
                await leaveRoom();
            }
            await signOut(auth);
        });

        // --- Room Management ---
        const listenToRooms = () => {
            const roomsRef = ref(db, 'rooms');
            onValue(roomsRef, (snapshot) => {
                roomListDiv.innerHTML = '';
                snapshot.forEach((childSnapshot) => {
                    const room = childSnapshot.val();
                    const roomId = childSnapshot.key;
                    if (room.status === 'active') {
                        const roomDiv = document.createElement('div');
                        roomDiv.innerHTML = `<span>${room.name}</span> <button data-room-id="${roomId}">ورود</button>`;
                        roomDiv.querySelector('button').addEventListener('click', () => joinRoom(roomId, room.name));
                        roomListDiv.appendChild(roomDiv);
                    }
                });
            });
        };

        createRoomBtn.addEventListener('click', async () => {
            const roomName = newRoomNameInput.value.trim();
            if (roomName && currentUser) {
                const newRoomRef = push(ref(db, 'rooms'));
                await set(newRoomRef, {
                    name: roomName,
                    creatorId: currentUser.uid,
                    createdAt: Date.now(),
                    status: 'active'
                });
                newRoomNameInput.value = '';
                joinRoom(newRoomRef.key, roomName);
            } else {
                alert("لطفاً نام اتاق را وارد کنید.");
            }
        });

        const joinRoom = async (roomId, roomName) => {
            currentRoomId = roomId;
            roomTitle.textContent = `اتاق: ${roomName}`;
            roomListSection.style.display = 'none';
            roomSection.style.display = 'block';

            // Add current user to room members
            const memberRef = ref(db, `rooms/${currentRoomId}/members/${currentUser.uid}`);
            const roomCreatorSnapshot = await get(ref(db, `rooms/${currentRoomId}/creatorId`));
            const isCreator = currentUser.uid === roomCreatorSnapshot.val();

            await set(memberRef, {
                username: userDisplayName,
                joinedAt: Date.now(),
                microphoneOn: micEnabled, // Initial state
                isCreator: isCreator
            });

            // Start listening to room members and chat messages
            listenToRoomMembers(currentRoomId);
            listenToChatMessages(currentRoomId);
            startWebRTC(); // Initialize WebRTC for the room
        };

        leaveRoomBtn.addEventListener('click', leaveRoom);

        async function leaveRoom() {
            if (!currentUser || !currentRoomId) return;

            // Remove user from room members
            await remove(ref(db, `rooms/${currentRoomId}/members/${currentUser.uid}`));

            // Stop all WebRTC connections
            for (const peerId in peerConnections) {
                peerConnections[peerId].close();
                delete peerConnections[peerId];
                document.getElementById(`audio-${peerId}`)?.remove();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            micEnabled = false;
            toggleMicBtn.textContent = 'میکروفون روشن';
            toggleMicBtn.style.backgroundColor = '#28a745'; // Green

            currentRoomId = null;
            roomSection.style.display = 'none';
            roomListSection.style.display = 'block';
            roomMembersList.innerHTML = '';
            chatMessagesDiv.innerHTML = '';
            remoteAudiosDiv.innerHTML = '';
        }

        const listenToRoomMembers = (roomId) => {
            const membersRef = ref(db, `rooms/${roomId}/members`);
            onValue(membersRef, (snapshot) => {
                roomMembersList.innerHTML = '';
                const currentMembers = new Set();
                snapshot.forEach((childSnapshot) => {
                    const member = childSnapshot.val();
                    const memberId = childSnapshot.key;
                    currentMembers.add(memberId);
                    const memberLi = document.createElement('li');
                    memberLi.textContent = `${member.username} ${member.microphoneOn ? '(میکروفون روشن)' : ''}`;
                    if (member.isCreator) {
                        memberLi.textContent += ' (سازنده)';
                    }
                    roomMembersList.appendChild(memberLi);

                    // Manage WebRTC connections based on members
                    if (memberId !== currentUser.uid && !peerConnections[memberId]) {
                        createPeerConnection(memberId);
                    }
                });

                // Close connections for users who left
                for (const peerId in peerConnections) {
                    if (!currentMembers.has(peerId) && peerId !== currentUser.uid) {
                        console.log(`Closing peer connection with ${peerId} (left room)`);
                        peerConnections[peerId].close();
                        delete peerConnections[peerId];
                        document.getElementById(`audio-${peerId}`)?.remove();
                    }
                }
            });
        };

        // --- Chat Messaging ---
        sendChatBtn.addEventListener('click', async () => {
            const chatText = chatInput.value.trim();
            if (chatText && currentUser && currentRoomId) {
                await push(ref(db, `rooms/${currentRoomId}/chatMessages`), {
                    senderId: currentUser.uid,
                    senderName: userDisplayName,
                    text: chatText,
                    timestamp: Date.now()
                });
                chatInput.value = '';
            }
        });

        // Allow sending message with Enter key
        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendChatBtn.click();
            }
        });

        const listenToChatMessages = (roomId) => {
            const chatRef = ref(db, `rooms/${roomId}/chatMessages`);
            onValue(chatRef, (snapshot) => {
                chatMessagesDiv.innerHTML = '';
                snapshot.forEach((childSnapshot) => {
                    const msg = childSnapshot.val();
                    const msgDiv = document.createElement('div');
                    msgDiv.classList.add('chat-message');
                    const messageDate = new Date(msg.timestamp);
                    const timeString = messageDate.toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit' });
                    msgDiv.innerHTML = `<strong>${msg.senderName}:</strong> ${msg.text} <span class="timestamp">${timeString}</span>`;
                    chatMessagesDiv.appendChild(msgDiv);
                });
                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Auto-scroll
            });
        };

        // --- WebRTC Core Logic ---
        toggleMicBtn.addEventListener('click', async () => {
            if (!localStream) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micEnabled = true;
                    toggleMicBtn.textContent = 'میکروفون خاموش';
                    toggleMicBtn.style.backgroundColor = '#dc3545'; // Red

                    // Add tracks to existing peer connections
                    for (const peerId in peerConnections) {
                        localStream.getTracks().forEach(track => {
                            peerConnections[peerId].addTrack(track, localStream);
                        });
                    }
                } catch (error) {
                    console.error("Error accessing microphone:", error);
                    alert("خطا در دسترسی به میکروفون. لطفاً اجازه دسترسی بدهید.");
                    micEnabled = false;
                }
            } else {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                micEnabled = false;
                toggleMicBtn.textContent = 'میکروفون روشن';
                toggleMicBtn.style.backgroundColor = '#28a745'; // Green

                // Remove tracks from peer connections
                for (const peerId in peerConnections) {
                    const pc = peerConnections[peerId];
                    pc.getSenders().forEach(sender => {
                        if (sender.track && sender.track.kind === 'audio') {
                            pc.removeTrack(sender);
                        }
                    });
                }
            }
            // Update microphone status in Firebase
            if (currentUser && currentRoomId) {
                update(ref(db, `rooms/${currentRoomId}/members/${currentUser.uid}`), { microphoneOn: micEnabled });
            }
        });

        async function startWebRTC() {
            // Initial setup: get local audio stream if mic is already enabled
            if (micEnabled && !localStream) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    // No need to add to PC here, members listener will create PCs and add streams
                } catch (error) {
                    console.error("Error getting initial microphone access:", error);
                    micEnabled = false;
                    toggleMicBtn.textContent = 'میکروفون روشن';
                    toggleMicBtn.style.backgroundColor = '#28a745'; // Green
                }
            }

            // This listener handles incoming signals from other users
            // Use once('value') to fetch initial data and then listen for changes.
            // For active signaling, onValue is correct.
            const signalsRef = ref(db, `rooms/${currentRoomId}/peerSignals`);
            onValue(signalsRef, async (snapshot) => {
                if (!currentUser) return; // Ensure user is authenticated

                snapshot.forEach(async (childSnapshot) => {
                    const peerId = childSnapshot.key;
                    if (peerId === currentUser.uid) return; // Don't process our own signals

                    const peerSignalData = childSnapshot.val();
                    if (!peerSignalData) return; // No data yet

                    if (!peerConnections[peerId]) {
                        // This case is handled by the member listener now.
                        // But good to have a fallback or warning.
                        console.warn(`Peer connection for ${peerId} not yet established by member listener.`);
                        return; 
                    }
                    const pc = peerConnections[peerId];

                    try {
                        if (peerSignalData.offer && pc.signalingState !== 'have-local-offer') { // Prevent re-processing offers we sent
                            console.log(`[WebRTC] Received OFFER from ${peerId}`);
                            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: peerSignalData.offer }));
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            // Send answer back
                            await update(ref(db, `rooms/${currentRoomId}/peerSignals/${currentUser.uid}`), {
                                answer: answer.sdp,
                                lastSignalTime: Date.now()
                            });
                            // Clear the offer after processing
                            await remove(ref(db, `rooms/${currentRoomId}/peerSignals/${peerId}/offer`));
                        }

                        if (peerSignalData.answer && pc.signalingState !== 'stable') { // Only process answer if not already stable
                            console.log(`[WebRTC] Received ANSWER from ${peerId}`);
                            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: peerSignalData.answer }));
                            // Clear the answer after processing
                            await remove(ref(db, `rooms/${currentRoomId}/peerSignals/${peerId}/answer`));
                        }

                        // Process ICE candidates
                        if (peerSignalData.candidates) {
                            const candidatesToRemove = [];
                            for (const candidateId in peerSignalData.candidates) {
                                const candidate = peerSignalData.candidates[candidateId];
                                try {
                                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                                    candidatesToRemove.push(candidateId);
                                } catch (e) {
                                    if (!pc.remoteDescription) {
                                        console.warn('Remote description not set yet for candidate:', candidate);
                                    } else {
                                        console.error('Error adding received ICE candidate:', e, candidate);
                                    }
                                }
                            }
                            // Remove processed candidates
                            if (candidatesToRemove.length > 0) {
                                const updates = {};
                                candidatesToRemove.forEach(id => {
                                    updates[id] = null;
                                });
                                await update(ref(db, `rooms/${currentRoomId}/peerSignals/${peerId}/candidates`), updates);
                            }
                        }
                    } catch (error) {
                        console.error(`Error processing signal from ${peerId}:`, error);
                    }
                });
            });
        }

        function createPeerConnection(peerId) {
            if (peerConnections[peerId]) return;

            console.log(`Creating new RTCPeerConnection for ${peerId}`);
            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    // Add more STUN/TURN servers for robustness in production.
                    // Example: { urls: 'turn:your.turn.server.com:3478', username: 'user', credential: 'password' }
                ]
            });

            peerConnections[peerId] = pc;

            // Add local stream to the peer connection if available
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }

            // --- Event Handlers for PeerConnection ---
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    console.log(`[WebRTC] Sending ICE candidate to ${peerId}`);
                    // Push candidate to Firebase
                    await push(ref(db, `rooms/${currentRoomId}/peerSignals/${currentUser.uid}/candidates`), {
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                    });
                    await update(ref(db, `rooms/${currentRoomId}/peerSignals/${currentUser.uid}`), { lastSignalTime: Date.now() });
                }
            };

            pc.ontrack = (event) => {
                console.log(`[WebRTC] Received remote stream from ${peerId}`);
                const audioEl = document.getElementById(`audio-${peerId}`) || document.createElement('audio');
                audioEl.id = `audio-${peerId}`;
                audioEl.autoplay = true;
                audioEl.controls = false; // Hide controls
                if (!audioEl.srcObject) { // Prevent setting srcObject multiple times
                    audioEl.srcObject = event.streams[0];
                }
                remoteAudiosDiv.appendChild(audioEl);
            };

            pc.onnegotiationneeded = async () => {
                try {
                    // This is where we create and send the offer
                    console.log(`[WebRTC] Negotiation needed for ${peerId}, creating offer.`);
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    // Send offer to Firebase
                    await update(ref(db, `rooms/${currentRoomId}/peerSignals/${currentUser.uid}`), {
                        offer: offer.sdp,
                        lastSignalTime: Date.now()
                    });
                } catch (error) {
                    console.error(`Error during onnegotiationneeded for ${peerId}:`, error);
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state for ${peerId}:`, pc.iceConnectionState);
                if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                    console.warn(`Connection with ${peerId} failed or disconnected.`);
                    // Depending on your app logic, you might want to re-negotiate or clean up.
                }
            };

            pc.onconnectionstatechange = () => {
                console.log(`PeerConnection state for ${peerId}:`, pc.connectionState);
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                    console.log(`Peer connection with ${peerId} has ended.`);
                    if (peerConnections[peerId]) {
                        peerConnections[peerId].close();
                        delete peerConnections[peerId];
                        document.getElementById(`audio-${peerId}`)?.remove();
                    }
                }
            };
        }
    </script>
</head>
<body>
    <div id="auth-section" class="section">
        <h1>به غول صوتی خوش آمدید!</h1>
        <input type="text" id="username-input" placeholder="نام کاربری (اختیاری)">
        <button id="login-anon-btn">ورود ناشناس</button>
        <div id="user-info" style="display: none; align-items: center; margin-top: 15px;">
            <p style="margin: 0; margin-left: 10px;">خوش آمدید، <span id="current-username" style="font-weight: bold;"></span>!</p>
            <button id="logout-btn">خروج</button>
        </div>
    </div>

    <div id="room-list-section" class="section" style="display: none;">
        <h2>اتاق‌های موجود</h2>
        <div id="room-list"></div>
        <input type="text" id="new-room-name" placeholder="نام اتاق جدید">
        <button id="create-room-btn">ایجاد اتاق</button>
    </div>

    <div id="room-section" class="section" style="display: none;">
        <h2 id="room-title"></h2>
        <button id="leave-room-btn">ترک اتاق</button>
        <button id="toggle-mic-btn">میکروفون روشن</button>

        <h3>اعضای اتاق:</h3>
        <ul id="room-members"></ul>

        <h3>چت متنی:</h3>
        <div id="chat-messages"></div>
        <div style="display: flex; gap: 10px;">
            <input type="text" id="chat-input" placeholder="پیام شما...">
            <button id="send-chat-btn">ارسال</button>
        </div>
        
        <!-- فضایی برای پخش صوت کاربران دیگر -->
        <h3>صوت کاربران دیگر:</h3>
        <div id="remote-audios">
            <!-- Audio tags will be dynamically added here -->
        </div>
    </div>
</body>
</html>
